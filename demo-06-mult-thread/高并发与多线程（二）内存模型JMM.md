# 高并发与多线程（二）内存模型JMM.md

## 一、JMM基础

### 并发编程的类型

并发编程中，需要解决的问题：线程之间如何通信以及线程之间如何同步
- 共享内存 

    在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信

- 消息传递

  在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。

Java并发采用的是**共享内存模型**

线程A与线程B之间如要通信的话，必须要经历下面2个步骤：

1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。
2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。

### 重排序

执行程序时为了提高性能，编译器和处理器会对指令进行重排序

重排序分为三类：

1. 编译器优化的重排序
2. 指令级的重排序
3. 内存系统的重排序

## 二、重排序与JMM的as-if-serial

数据依赖性
如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。


|名称|代码示例|说明
|---|---|---|
|写后读|a = 1;b = a;|写一个变量之后，再读这个位置。
|写后写|a = 1;a = 2;|写一个变量之后，再写这个变量。
|读后写|a = b;b = 1;|读一个变量之后，再写这个变量。

上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。

在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从happens- before的定义我们可以看出，JMM同样遵从这一目标。

## 三、Java内存模型

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，
而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行。

- 主内存 
  - 主要存储的是Java实例对象以及线程之间的共享变量，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。

- 工作内存 
  - 
  - 
  - 有的书籍中也称为本地内存，主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。