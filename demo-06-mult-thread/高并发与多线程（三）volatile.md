# 高并发与多线程（三）volatile关键字

[参考文章](https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/currency/Java%E5%B9%B6%E5%8F%91%E6%8C%87%E5%8D%973%EF%BC%9A%E5%B9%B6%E5%8F%91%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8CCAS%E6%93%8D%E4%BD%9C.md)

## 1. 三个特性

Java内存模型中仅仅定义了线程和内存之间那种抽象的关系。

1. **原子性：** 一个同步方法或者代码块中所做的修改对于使用了同一个锁的同步方法或代码块都具有原子性和可见性。 
同步方法或代码块之间的执行过程都会和代码指定的执行顺序保持一致。即使代码块内部指令也许是乱序执行的，也不会对使用了同步的其它线程造成任何影响。
2. **可见性：** 在哪些情况下，一个线程执行的结果对另一个线程是可见的。这里需要关心的结果有，写入的字段以及读取这个字段所看到的值。
3. **有序性：** 在什么情况下，某个线程的操作结果对其它线程来看是无序的。最主要的乱序执行问题主要表现在读写操作和赋值语句的相互执行顺序上。

## 2. volatile关键字详解：在JMM中volatile的内存语义是锁

volatile变量自身具有下列特性：监视器锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的long型和double型变量，
只要它是volatile变量，对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。

## 3. 锁释放和获取的内存语义

当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。

**总结**

- 线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。
- 线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。
- 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。


## 4. concurrent包的实现

如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式

首先，声明共享变量为volatile；
然后，使用CAS的原子条件更新来实现线程之间的同步；
同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。

## 5. synchronized实现原理

synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。

1. 普通同步方法，锁是当前实例对象； 
2. 静态同步方法，锁是当前类的class对象； 
3. 同步方法块，锁是括号里面的对象。

